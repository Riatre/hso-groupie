// Copyright 2022 Riatre Foo
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef JBIG2CONS_JBIG2CONS_H_
#define JBIG2CONS_JBIG2CONS_H_

#include <concepts>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <span>
#include <stdexcept>
#include <vector>

#define CHECK(condition)                                   \
  if (!(condition)) {                                      \
    throw std::runtime_error("Check failed: " #condition); \
  }

struct jbig2enc_ctx;

namespace jbjbarith {

// The data buffer in this Bitmap would match those in JBIG2Bitmap in Xpdf.
class Bitmap final {
 public:
  Bitmap(uint32_t w, uint32_t h) : w_(w), h_(h), data_((w + 7) / 8 * h) {}
  Bitmap(const Bitmap&) = default;
  Bitmap& operator=(const Bitmap&) = default;
  Bitmap(Bitmap&&) = default;
  Bitmap& operator=(Bitmap&&) = default;

  void SetPixel(int x, int y) {
    CHECK(x >= 0 && x < w_);
    CHECK(y >= 0 && y < h_);
    data_[y * (w_ + 7) / 8 + x / 8] |= std::byte(1 << (7 - x % 8));
  }

  void ClearPixel(int x, int y) {
    CHECK(x >= 0 && x < w_);
    CHECK(y >= 0 && y < h_);
    data_[y * (w_ + 7) / 8 + x / 8] &= std::byte(~(1 << (7 - x % 8)));
  }

  size_t ByteSize() const { return data_.size(); }

  void SetDataFromBytes(std::span<const std::byte> bytes) {
    CHECK(bytes.size() <= data_.size());
    std::memcpy(data_.data(), bytes.data(), bytes.size());
  }

  uint32_t Width() const { return w_; }
  uint32_t Height() const { return h_; }
  std::span<const std::byte> Data() const { return data_; }

 private:
  uint32_t w_, h_;
  std::vector<std::byte> data_;
};

class ArithEncoder final {
 public:
  enum class Proc : int {
    IAAI = 0,
    IADH,
    IADS,
    IADT,
    IADW,
    IAEX,
    IAFS,
    IAIT,
    IARDH,
    IARDW,
    IARDX,
    IARDY,
    IARI,
  };

  ArithEncoder();
  ~ArithEncoder();
  ArithEncoder(const ArithEncoder&) = delete;
  ArithEncoder& operator=(const ArithEncoder&) = delete;

  void Reset();
  void Finalize();
  void WriteInt(Proc proc, int value);
  void WriteOOB(Proc proc);
  void WriteIAID(int symcodelen, int value);
  void WriteBitImage(const Bitmap& bitmap);
  void WriteRefinement(const Bitmap& from, const Bitmap& to);
  void WriteBit(unsigned int ctxnum, int bit);
  void ToBuffer(std::byte* buffer) const;
  size_t Size() const;

 private:
  bool finalized_ = false;
  struct jbig2enc_ctx* arith_encoder_ctx_;
};

}  // namespace jbjbarith

#endif
