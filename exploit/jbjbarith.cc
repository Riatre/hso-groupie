// Copyright 2022 Riatre Foo
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "jbjbarith.h"

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include <cstdint>
#include <string_view>

#define _WHY_WOULD_SOMEONE_DO_THIS_INSTEAD_OF_JUST_PATCH_THE_DEPENDENCY_OH_WELL
#include "jbig2arith.h"
#undef _WHY_WOULD_SOMEONE_DO_THIS_INSTEAD_OF_JUST_PATCH_THE_DEPENDENCY_OH_WELL

namespace py = pybind11;

namespace {

std::vector<std::byte> BitmapToLeptonica1bppImage(
    const jbjbarith::Bitmap& bitmap) {
  auto input_line_width = (bitmap.Width() + 7) / 8;
  auto line_width = (bitmap.Width() + 31) / 32 * 4;
  std::vector<std::byte> image(line_width * bitmap.Height());
  for (int y = 0; y < bitmap.Height(); y++) {
    memcpy(image.data() + line_width * y,
           bitmap.Data().data() + input_line_width * y, input_line_width);
    for (int x = 0; x < line_width / 4; x++) {
      std::reverse(image.data() + line_width * y + x * 4,
                   image.data() + line_width * y + x * 4 + 4);
    }
  }
  return image;
}

}  // namespace

namespace jbjbarith {

ArithEncoder::ArithEncoder() {
  arith_encoder_ctx_ = new jbig2enc_ctx;
  jbig2enc_init(arith_encoder_ctx_);
}

ArithEncoder::~ArithEncoder() {
  jbig2enc_dealloc(arith_encoder_ctx_);
  delete arith_encoder_ctx_;
  arith_encoder_ctx_ = nullptr;
}

void ArithEncoder::Finalize() {
  CHECK(!finalized_);
  jbig2enc_final(arith_encoder_ctx_);
  finalized_ = true;
}

void ArithEncoder::Reset() {
  CHECK(!finalized_);
  jbig2enc_reset(arith_encoder_ctx_);
}

static_assert(JBIG2_IAAI == static_cast<int>(ArithEncoder::Proc::IAAI));
static_assert(JBIG2_IADH == static_cast<int>(ArithEncoder::Proc::IADH));
static_assert(JBIG2_IADS == static_cast<int>(ArithEncoder::Proc::IADS));
static_assert(JBIG2_IADT == static_cast<int>(ArithEncoder::Proc::IADT));
static_assert(JBIG2_IADW == static_cast<int>(ArithEncoder::Proc::IADW));
static_assert(JBIG2_IAEX == static_cast<int>(ArithEncoder::Proc::IAEX));
static_assert(JBIG2_IAFS == static_cast<int>(ArithEncoder::Proc::IAFS));
static_assert(JBIG2_IAIT == static_cast<int>(ArithEncoder::Proc::IAIT));
static_assert(JBIG2_IARDH == static_cast<int>(ArithEncoder::Proc::IARDH));
static_assert(JBIG2_IARDW == static_cast<int>(ArithEncoder::Proc::IARDW));
static_assert(JBIG2_IARDX == static_cast<int>(ArithEncoder::Proc::IARDX));
static_assert(JBIG2_IARDY == static_cast<int>(ArithEncoder::Proc::IARDY));
static_assert(JBIG2_IARI == static_cast<int>(ArithEncoder::Proc::IARI));

void ArithEncoder::WriteInt(Proc proc, int value) {
  CHECK(!finalized_);
  jbig2enc_int(arith_encoder_ctx_, static_cast<int>(proc), value);
}

void ArithEncoder::WriteOOB(Proc proc) {
  CHECK(!finalized_);
  jbig2enc_oob(arith_encoder_ctx_, static_cast<int>(proc));
}

void ArithEncoder::WriteIAID(int symcodelen, int value) {
  CHECK(!finalized_);
  jbig2enc_iaid(arith_encoder_ctx_, symcodelen, value);
}

void ArithEncoder::WriteBitImage(const Bitmap& bitmap) {
  CHECK(!finalized_);
  auto image = BitmapToLeptonica1bppImage(bitmap);
  jbig2enc_bitimage(
      arith_encoder_ctx_, reinterpret_cast<const uint8_t*>(image.data()),
      bitmap.Width(), bitmap.Height(), /*duplicate_line_removal=*/false);
}

void ArithEncoder::WriteBit(unsigned int context, int bit) {
  CHECK(!finalized_);
  jbig2enc_encode_bit(arith_encoder_ctx_, context, bit);
}

void ArithEncoder::WriteRefinement(const Bitmap& from, const Bitmap& to) {
  CHECK(!finalized_);
  auto image_from = BitmapToLeptonica1bppImage(from);
  auto image_to = BitmapToLeptonica1bppImage(to);
  jbig2enc_refine(arith_encoder_ctx_,
                  reinterpret_cast<const uint8_t*>(image_from.data()),
                  from.Width(), from.Height(),
                  reinterpret_cast<const uint8_t*>(image_to.data()), to.Width(),
                  to.Height(), 0, 0);
}

size_t ArithEncoder::Size() const {
  return jbig2enc_datasize(arith_encoder_ctx_);
}

void ArithEncoder::ToBuffer(std::byte* buffer) const {
  CHECK(finalized_);
  jbig2enc_tobuffer(arith_encoder_ctx_, reinterpret_cast<uint8_t*>(buffer));
}

PYBIND11_MODULE(jbjbarith, m) {
  py::class_<Bitmap>(m, "Bitmap")
      .def(py::init<uint32_t, uint32_t>(), py::arg("w"), py::arg("h"))
      .def(py::init([](uint32_t w, uint32_t h, py::bytes data) {
             auto ptr = std::make_unique<Bitmap>(w, h);
             std::string_view sv{data};
             ptr->SetDataFromBytes(
                 {reinterpret_cast<const std::byte*>(sv.data()), sv.size()});
             return ptr;
           }),
           py::arg("w"), py::arg("h"), py::arg("data"))
      .def(py::init([](py::bytes data) {
             std::string_view sv{data};
             CHECK(sv.size() != 0);
             CHECK(sv.size() * 8 > sv.size());
             auto ptr = std::make_unique<Bitmap>(sv.size() * 8, 1);
             ptr->SetDataFromBytes(
                 {reinterpret_cast<const std::byte*>(sv.data()), sv.size()});
             return ptr;
           }),
           py::arg("data"))
      .def_property_readonly("width", &Bitmap::Width)
      .def_property_readonly("height", &Bitmap::Height)
      .def_property_readonly("data",
                             [](const Bitmap& bitmap) {
                               auto data = bitmap.Data();
                               return py::bytes(
                                   reinterpret_cast<const char*>(data.data()),
                                   data.size());
                             })
      .def("set_pixel", &Bitmap::SetPixel)
      .def("clear_pixel", &Bitmap::ClearPixel);
  py::enum_<ArithEncoder::Proc>(m, "Proc")
      .value("IAAI", ArithEncoder::Proc::IAAI)
      .value("IADH", ArithEncoder::Proc::IADH)
      .value("IADS", ArithEncoder::Proc::IADS)
      .value("IADT", ArithEncoder::Proc::IADT)
      .value("IADW", ArithEncoder::Proc::IADW)
      .value("IAEX", ArithEncoder::Proc::IAEX)
      .value("IAFS", ArithEncoder::Proc::IAFS)
      .value("IAIT", ArithEncoder::Proc::IAIT)
      .value("IARDH", ArithEncoder::Proc::IARDH)
      .value("IARDW", ArithEncoder::Proc::IARDW)
      .value("IARDX", ArithEncoder::Proc::IARDX)
      .value("IARDY", ArithEncoder::Proc::IARDY)
      .value("IARI", ArithEncoder::Proc::IARI);
  py::class_<ArithEncoder>(m, "ArithmeticEncoder")
      .def(py::init<>())
      .def("write_int", &ArithEncoder::WriteInt, py::arg("proc"),
           py::arg("value"))
      .def("write_oob", &ArithEncoder::WriteOOB, py::arg("proc"))
      .def("write_iaid", &ArithEncoder::WriteIAID, py::arg("symcodelen"),
           py::arg("value"))
      .def("write_bit_image", &ArithEncoder::WriteBitImage, py::arg("bitmap"))
      .def("write_refine", &ArithEncoder::WriteRefinement, py::arg("from"),
           py::arg("to"))
      .def("write_bit", &ArithEncoder::WriteBit, py::arg("ctx_num"),
           py::arg("bit"))
      .def("size", &ArithEncoder::Size)
      .def("finalize", &ArithEncoder::Finalize)
      .def("reset", &ArithEncoder::Reset)
      .def("to_bytes", [](const ArithEncoder& encoder) {
        std::vector<std::byte> buffer(encoder.Size());
        encoder.ToBuffer(buffer.data());
        return py::bytes(reinterpret_cast<const char*>(buffer.data()),
                         buffer.size());
      });
}

}  // namespace jbjbarith
